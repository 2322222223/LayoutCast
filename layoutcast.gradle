
buildscript {
	repositories {
		jcenter()
	}
	dependencies {
		def pluginVersion

		def searchGradleVersion = { java.lang.Class clazz ->
			if (!clazz.getName().startsWith('com.android.build.gradle')) {
				return
			}
			java.lang.ClassLoader cl = clazz.getClassLoader()
			if (!cl instanceof URLClassLoader) {
				return
			}
			java.util.regex.Pattern p = java.util.regex.Pattern.compile('[/\\\\]+com.android.tools.build[/\\\\]+gradle[/\\\\]+([^/\\\\]+)[/\\\\]+')
			cl.URLs.each {
				URL url = it
				java.util.regex.Matcher m = p.matcher(url.path)
				if (m.find()) {
					pluginVersion = m.group(1)
					return true
				}
			}
		}
		tasks.each { Task t ->
			searchGradleVersion(t.getClass())
			if (pluginVersion) {
				return true;
			}
			// search sub tasks
//			t.dependsOn.each {
//				searchGradleVersion(it.getClass())
//				if (pluginVersion) {
//					return true;
//				}
//			}
//			if (pluginVersion) {
//				return true
//			}
		}

		if (pluginVersion == null)
			pluginVersion = '1.3.0'
		def cp = "com.android.tools.build:gradle:${pluginVersion}"
		classpath cp

		System.setProperty('gradleVersion', pluginVersion)
	}
}

//buildscript {
//	repositories {
//		jcenter()
//	}
//	dependencies {
//		classpath 'com.android.tools.build:gradle:1.3.0'
//	}
//}

def lcGradleVersion = System.getProperty('gradleVersion')
def lcPackageName
def lcAppName
def lcActivityName

println "LayoutCast 2.0 [com.android.tools.build:gradle:${lcGradleVersion}]"

afterEvaluate {
	def tProcessDebugManifest = tasks.getByName('processDebugManifest')
	if (tProcessDebugManifest) {
		task lcBeforeManifest << {
			// com.android.build.gradle.internal.dependency.ManifestDependencyImpl
			def cMDI = tProcessDebugManifest.getClass().getClassLoader().loadClass('com.android.build.gradle.internal.dependency.ManifestDependencyImpl')
			def lcAm = cMDI.getConstructor(File.class, List.class).newInstance(new File('/Users/mmin18/Desktop/AndroidManifest.xml'), new ArrayList())
			tProcessDebugManifest.libraries = new ArrayList<?>(tProcessDebugManifest.libraries)
			tProcessDebugManifest.libraries.add(lcAm)
		}
		tProcessDebugManifest.dependsOn(lcBeforeManifest)

		task lcAfterManifest << {
			def outManifest
			tProcessDebugManifest.outputs.files.any {
				outManifest = it
				return true
			}
			def xp = javax.xml.xpath.XPathFactory.newInstance().newXPath()
			xp.setNamespaceContext(new javax.xml.namespace.NamespaceContext() {
				@Override
				String getNamespaceURI(String prefix) {
					return 'http://schemas.android.com/apk/res/android'
				}

				@Override
				String getPrefix(String namespaceURI) {
					return null
				}

				@Override
				Iterator getPrefixes(String namespaceURI) {
					return null
				}
			});

			def fis = new FileInputStream(outManifest)
			def ins = new org.xml.sax.InputSource(fis)
			lcPackageName = xp.compile('/manifest/@package').evaluate(ins)
			fis.close()

			fis = new FileInputStream(outManifest)
			ins = new org.xml.sax.InputSource(fis)
			lcAppName = xp.compile('/manifest/application/@android:name').evaluate(ins)
			fis.close()

			fis = new FileInputStream(outManifest)
			ins = new org.xml.sax.InputSource(fis)
			lcActivityName = xp.compile('/manifest/application/activity[intent-filter/action/@android:name=\"android.intent.action.MAIN\" and intent-filter/category/@android:name=\"android.intent.category.LAUNCHER\"]/@android:name').evaluate(ins)
			fis.close()
		}
		tProcessDebugManifest.finalizedBy(lcAfterManifest)
	} else {
		throw new Exception('LayoutCast cannot process AndroidManifest.xml')
	}

	def tJavac = tasks.findByName('compileDebugJavaWithJavac')
	if (tJavac == null) {
		tJavac = tasks.findByName('compileDebugJava')
	}
	if (tJavac) {
		task lcAfterJavac << {
			// TODO: may break incremental task?
			org.gradle.api.tasks.compile.JavaCompile jc = tJavac
			java.io.File outDir = jc.getDestinationDir()
			if (lcAppName) {
				java.io.File appFile = outDir
				java.util.StringTokenizer st = new java.util.StringTokenizer(lcAppName, ".")
				while (st.hasMoreTokens()) {
					String nt = st.nextToken()
					if (!st.hasMoreTokens()) {
						nt += '.class'
					}
					appFile = new File(appFile, nt)
				}
				if (appFile.length() > 0) {
					InputStream ins = new FileInputStream(appFile);
					org.objectweb.asm.ClassReader cr = new org.objectweb.asm.ClassReader(ins);
					org.objectweb.asm.ClassWriter cw = new org.objectweb.asm.ClassWriter(cr, org.objectweb.asm.ClassWriter.COMPUTE_MAXS);
					org.objectweb.asm.ClassVisitor cv = new org.objectweb.asm.ClassVisitor(org.objectweb.asm.Opcodes.ASM4,cw) {
						@Override
						public org.objectweb.asm.MethodVisitor visitMethod(int access, String name, String desc,
																		   String signature, String[] exceptions) {
							if (name == 'onCreate') {
								org.objectweb.asm.MethodVisitor mv = cw.visitMethod(access, name, desc, signature, exceptions);
								return new org.objectweb.asm.MethodVisitor(org.objectweb.asm.Opcodes.ASM4, mv) {
									@Override
									public void visitCode() {
										super.visitCode();

										// com.github.mmin18.LayoutCast.init(this);
										mv.visitVarInsn(org.objectweb.asm.Opcodes.ALOAD, 0);
										mv.visitMethodInsn(org.objectweb.asm.Opcodes.INVOKESTATIC, 'com/github/mmin18/layoutcast/LayoutCast', 'init', '(Landroid/content/Context;)V', false);

										println "LayoutCast added init code in ${appFile}.onCreate()"
									}
								}
							} else {
								return super.visitMethod(access, name, desc, signature, exceptions)
							}
						}
					}
					cr.accept(cv, 0)
					byte[] bytes = cw.toByteArray()
					ins.close()
					java.io.FileOutputStream fos = new java.io.FileOutputStream(appFile)
					fos.write(bytes)
					fos.close()
				} else {
					throw new Exception('LayoutCast cannot find ' + appFile)
				}
			}
		}
		tJavac.finalizedBy(lcAfterJavac)
	} else {
		throw new Exception('LayoutCast cannot process init code')
	}

	def tDex = tasks.findByName('dexDebug')
	if (tDex == null) {
		tDex = tasks.findByName('transformClassesWithDexForDebug')
	}
	if (tDex) {
		task lcBeforeDex << {
			println tDex.getClass()
			// 1.5
//			println tDex.consumedInputStreams
//			println tDex.referencedInputStreams

			// 1.3
			tDex.libraries = new ArrayList<?>(tDex.libraries)
			tDex.libraries.add(new File('/Users/mmin18/Desktop/lc.jar'))
		}
		tDex.dependsOn(lcBeforeDex)
	} else {
		throw new Exception('LayoutCast cannot process dex')
	}
}